#include <iostream>
#include <cstring>
#include <cstdlib>
using namespace std;
int main()
{
	int days[2][13] = {{0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31},
					   {0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}};
	// days[][i]存储i月的天数，第一维1表示闰年，0表示平年
	int n;
	char s[20], s2[10], s3[10];
	cin >> n;
	while (n--)
	{
		int y = 2021, m = 1, d = 3, x; // y,m,d分别是当前的年月日，x为要找的数
		int run = 0, t = 0;			   // run表示当前是否是闰年，初始2021年不是闰年
		// t的含义如下：
		//首先考虑到整个s串太长，无法全部存在内存中，故考虑每次只生成并存储一天对应的串
		// t记录之前已经生成的串的字符总数，用于定位当前串在s串中的位置
		//考虑到一个数要么在一个串的内部，要么在两个串的交界处，而在交界处时
		//一定只有一个字符来自前一个串，故在每次查找时，将上一个串的最后一个字符记录下来
		//放在当前串的开头，即可保证正确性。
		cin >> x;
		//因为要找的数只可能是1-100，直接用两个if来转字符串，存入s2中。
		//当然也可以使用库函数itoa()
		if (x < 10)
		{
			s2[0] = x + '0';
			s2[1] = 0;
		}
		else if (x < 100)
		{
			s2[0] = x / 10 + '0';
			s2[1] = x % 10 + '0';
			s2[2] = 0;
		}
		else
			strcpy(s2, "100");
		int l = strlen(s2);		   //记录s2的长度
		s[0] = ' ';				   //开始时，给s[0]赋一个不可能出现的字符避免错误
		s[9] = 0;				   //注意设终止符
		bool flag = 0;			   // flag记录是否已找到
		while (y < 10000 && !flag) //逐日生成对应字符串并查找，直到全部生成或找到
		{
			//将y,m,d各位转成字符存储到s中
			s[1] = y / 1000 + '0';
			s[2] = y / 100 % 10 + '0';
			s[3] = y / 10 % 10 + '0';
			s[4] = y % 10 + '0';
			s[5] = m / 10 + '0';
			s[6] = m % 10 + '0';
			s[7] = d / 10 + '0';
			s[8] = d % 10 + '0';
			//枚举s2在s中的开始位置并判断是否相等
			for (int i = 0; i <= 9 - l; i++)
			{
				//先用strcpy把i位置开始的子串复制到s3中
				//并在合适的地方设终止符，来方便使用strcmp比较
				strcpy(s3, s + i);
				s3[l] = 0;
				if (strcmp(s3, s2) == 0)
				{
					//若找到，按前面分析，t+i便是在整个串中的位置
					//输出并将flag置1
					cout << t + i << endl;
					flag = 1;
					break;
				}
			}
			if (!flag) //若未找到，将日期加1
			{
				d++;
				if (d > days[run][m]) //判断月份是否需要+1
				{
					m++;
					d = 1;
				}
				if (m > 12) //判断年份是否需要+1
				{
					y++;
					//若年份+1，重新判断是否是闰年
					run = (y % 4 == 0 && y % 100 != 0 || y % 400 == 0);
					m = 1;
				}
				//按照上面的分析，将当前串的最后一个字符存到下一个串的第一个字符中
				//并将t的值累加8
				s[0] = s[8];
				t += 8;
			}
		}
		if (!flag) //若最后仍未找到，输出-1
			cout << -1 << endl;
	}
	return 0;
}
