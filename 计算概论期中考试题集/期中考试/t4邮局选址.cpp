#include <iostream>
using namespace std;
int main()
{
	//首先观察得到一个结论：在题述条件下，当居民点数量是奇数时，选址在
	//最中间的居民点能使距离和最小，而当居民点数量是偶数时，选址在最中间
	//的两个居民点构成的线段上的任意一点
	//图解和数学证明详见附件邮局选址.pdf

	//在得出上述结论后，一般只需用一个数组存储坐标，并如上确定邮局位置，
	//再用公式计算距离之和即可，下面给出一种不用数组的方法
	int T;
	cin >> T;
	while (T--)
	{
		int n, ans = 0, x, loc;
		// ans计算距离和,loc为邮局选址的居民点的编号，x为临时输入变量
		cin >> n;
		loc = n / 2 + 1; //根据上面的结论计算loc（偶数时也不妨选址在一个居民点上）
		for (int i = 1; i <= n; i++)
		{
			cin >> x;
			if (i < loc) //在邮局左边的居民点，其坐标对答案贡献的系数是-1
				ans -= x;
			else if (i > loc) //在邮局右边的居民点，其坐标对答案贡献的系数是1
				ans += x;
			//对于邮局所选址的居民点，其坐标在n为奇数是对答案无贡献，在n为偶数时对答案贡献的系数是1
			else if (n % 2 == 0)
				ans += x;
		}
		cout << ans << endl;
	}
	return 0;
}
